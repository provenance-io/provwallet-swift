// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: provenance/reward/v1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// QueryRewardProgramByIDRequest queries for the Reward Program with an identifier of id
public struct Provenance_Reward_V1_QueryRewardProgramByIDRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the reward program to query.
  public var id: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryRewardProgramByIDResponse contains the requested RewardProgram
public struct Provenance_Reward_V1_QueryRewardProgramByIDResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The reward program object that was queried for.
  public var rewardProgram: Provenance_Reward_V1_RewardProgram {
    get {return _rewardProgram ?? Provenance_Reward_V1_RewardProgram()}
    set {_rewardProgram = newValue}
  }
  /// Returns true if `rewardProgram` has been explicitly set.
  public var hasRewardProgram: Bool {return self._rewardProgram != nil}
  /// Clears the value of `rewardProgram`. Subsequent reads from it will return its default value.
  public mutating func clearRewardProgram() {self._rewardProgram = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rewardProgram: Provenance_Reward_V1_RewardProgram? = nil
}

/// QueryRewardProgramsRequest queries for all reward programs matching the query_type
public struct Provenance_Reward_V1_QueryRewardProgramsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A filter on the types of reward programs.
  public var queryType: Provenance_Reward_V1_QueryRewardProgramsRequest.QueryType = .unspecified

  /// pagination defines an optional pagination for the request.
  public var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// QueryType is the state of reward program to query
  public enum QueryType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// unspecified type
    case unspecified // = 0

    /// all reward programs states
    case all // = 1

    /// pending reward program state=
    case pending // = 2

    /// active reward program state
    case active // = 3

    /// pending and active reward program states
    case outstanding // = 4

    /// finished reward program state
    case finished // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .all
      case 2: self = .pending
      case 3: self = .active
      case 4: self = .outstanding
      case 5: self = .finished
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .all: return 1
      case .pending: return 2
      case .active: return 3
      case .outstanding: return 4
      case .finished: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

#if swift(>=4.2)

extension Provenance_Reward_V1_QueryRewardProgramsRequest.QueryType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Provenance_Reward_V1_QueryRewardProgramsRequest.QueryType] = [
    .unspecified,
    .all,
    .pending,
    .active,
    .outstanding,
    .finished,
  ]
}

#endif  // swift(>=4.2)

/// QueryRewardProgramsResponse contains the list of RewardPrograms matching the query
public struct Provenance_Reward_V1_QueryRewardProgramsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of RewardProgram objects matching the query_type.
  public var rewardPrograms: [Provenance_Reward_V1_RewardProgram] = []

  /// pagination defines an optional pagination for the response.
  public var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// QueryClaimPeriodRewardDistributionsRequest queries for all the ClaimPeriodRewardDistributions with pagination.
public struct Provenance_Reward_V1_QueryClaimPeriodRewardDistributionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pagination defines an optional pagination for the request.
  public var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// QueryClaimPeriodRewardDistributionsResponse returns the list of paginated ClaimPeriodRewardDistributions
public struct Provenance_Reward_V1_QueryClaimPeriodRewardDistributionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of all ClaimPeriodRewardDistribution objects queried for.
  public var claimPeriodRewardDistributions: [Provenance_Reward_V1_ClaimPeriodRewardDistribution] = []

  /// pagination defines an optional pagination for the response.
  public var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// QueryClaimPeriodRewardDistributionsByIDRequest queries for a single ClaimPeriodRewardDistribution
public struct Provenance_Reward_V1_QueryClaimPeriodRewardDistributionsByIDRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The reward program that the claim period reward distribution belongs to.
  public var rewardID: UInt64 = 0

  /// The claim period that the claim period reward distribution was created for.
  public var claimPeriodID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QueryClaimPeriodRewardDistributionsByIDResponse returns the requested ClaimPeriodRewardDistribution
public struct Provenance_Reward_V1_QueryClaimPeriodRewardDistributionsByIDResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ClaimPeriodRewardDistribution object that was queried for.
  public var claimPeriodRewardDistribution: Provenance_Reward_V1_ClaimPeriodRewardDistribution {
    get {return _claimPeriodRewardDistribution ?? Provenance_Reward_V1_ClaimPeriodRewardDistribution()}
    set {_claimPeriodRewardDistribution = newValue}
  }
  /// Returns true if `claimPeriodRewardDistribution` has been explicitly set.
  public var hasClaimPeriodRewardDistribution: Bool {return self._claimPeriodRewardDistribution != nil}
  /// Clears the value of `claimPeriodRewardDistribution`. Subsequent reads from it will return its default value.
  public mutating func clearClaimPeriodRewardDistribution() {self._claimPeriodRewardDistribution = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _claimPeriodRewardDistribution: Provenance_Reward_V1_ClaimPeriodRewardDistribution? = nil
}

/// QueryRewardDistributionsByAddressRequest queries for reward claims by address that match the claim_status.
public struct Provenance_Reward_V1_QueryRewardDistributionsByAddressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address that the claim belongs to.
  public var address: String = String()

  /// The status that the reward account must have.
  public var claimStatus: Provenance_Reward_V1_RewardAccountState.ClaimStatus = .unspecified

  /// pagination defines an optional pagination for the request.
  public var pagination: Cosmos_Base_Query_V1beta1_PageRequest {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageRequest()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageRequest? = nil
}

/// QueryRewardDistributionsByAddressResponse returns the reward claims for an address that match the claim_status.
public struct Provenance_Reward_V1_QueryRewardDistributionsByAddressResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address that the reward account belongs to.
  public var address: String = String()

  /// List of RewardAccounts queried for.
  public var rewardAccountState: [Provenance_Reward_V1_RewardAccountResponse] = []

  /// pagination defines an optional pagination for the response.
  public var pagination: Cosmos_Base_Query_V1beta1_PageResponse {
    get {return _pagination ?? Cosmos_Base_Query_V1beta1_PageResponse()}
    set {_pagination = newValue}
  }
  /// Returns true if `pagination` has been explicitly set.
  public var hasPagination: Bool {return self._pagination != nil}
  /// Clears the value of `pagination`. Subsequent reads from it will return its default value.
  public mutating func clearPagination() {self._pagination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pagination: Cosmos_Base_Query_V1beta1_PageResponse? = nil
}

/// RewardAccountResponse is an address' reward claim for a reward program's claim period.
public struct Provenance_Reward_V1_RewardAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the reward program that this claim belongs to.
  public var rewardProgramID: UInt64 = 0

  /// total rewards claimed for all eligible claim periods in program.
  public var totalRewardClaim: Cosmos_Base_V1beta1_Coin {
    get {return _totalRewardClaim ?? Cosmos_Base_V1beta1_Coin()}
    set {_totalRewardClaim = newValue}
  }
  /// Returns true if `totalRewardClaim` has been explicitly set.
  public var hasTotalRewardClaim: Bool {return self._totalRewardClaim != nil}
  /// Clears the value of `totalRewardClaim`. Subsequent reads from it will return its default value.
  public mutating func clearTotalRewardClaim() {self._totalRewardClaim = nil}

  /// The status of the claim.
  public var claimStatus: Provenance_Reward_V1_RewardAccountState.ClaimStatus = .unspecified

  /// The claim period that the claim belongs to.
  public var claimID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _totalRewardClaim: Cosmos_Base_V1beta1_Coin? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "provenance.reward.v1"

extension Provenance_Reward_V1_QueryRewardProgramByIDRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryRewardProgramByIDRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Provenance_Reward_V1_QueryRewardProgramByIDRequest, rhs: Provenance_Reward_V1_QueryRewardProgramByIDRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_QueryRewardProgramByIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryRewardProgramByIDResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reward_program"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rewardProgram) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rewardProgram {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Provenance_Reward_V1_QueryRewardProgramByIDResponse, rhs: Provenance_Reward_V1_QueryRewardProgramByIDResponse) -> Bool {
    if lhs._rewardProgram != rhs._rewardProgram {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_QueryRewardProgramsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryRewardProgramsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "query_type"),
    99: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.queryType) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.queryType != .unspecified {
      try visitor.visitSingularEnumField(value: self.queryType, fieldNumber: 1)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Provenance_Reward_V1_QueryRewardProgramsRequest, rhs: Provenance_Reward_V1_QueryRewardProgramsRequest) -> Bool {
    if lhs.queryType != rhs.queryType {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_QueryRewardProgramsRequest.QueryType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "QUERY_TYPE_UNSPECIFIED"),
    1: .same(proto: "QUERY_TYPE_ALL"),
    2: .same(proto: "QUERY_TYPE_PENDING"),
    3: .same(proto: "QUERY_TYPE_ACTIVE"),
    4: .same(proto: "QUERY_TYPE_OUTSTANDING"),
    5: .same(proto: "QUERY_TYPE_FINISHED"),
  ]
}

extension Provenance_Reward_V1_QueryRewardProgramsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryRewardProgramsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reward_programs"),
    99: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rewardPrograms) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rewardPrograms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rewardPrograms, fieldNumber: 1)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Provenance_Reward_V1_QueryRewardProgramsResponse, rhs: Provenance_Reward_V1_QueryRewardProgramsResponse) -> Bool {
    if lhs.rewardPrograms != rhs.rewardPrograms {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_QueryClaimPeriodRewardDistributionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryClaimPeriodRewardDistributionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    99: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Provenance_Reward_V1_QueryClaimPeriodRewardDistributionsRequest, rhs: Provenance_Reward_V1_QueryClaimPeriodRewardDistributionsRequest) -> Bool {
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_QueryClaimPeriodRewardDistributionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryClaimPeriodRewardDistributionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "claim_period_reward_distributions"),
    99: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.claimPeriodRewardDistributions) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.claimPeriodRewardDistributions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.claimPeriodRewardDistributions, fieldNumber: 1)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Provenance_Reward_V1_QueryClaimPeriodRewardDistributionsResponse, rhs: Provenance_Reward_V1_QueryClaimPeriodRewardDistributionsResponse) -> Bool {
    if lhs.claimPeriodRewardDistributions != rhs.claimPeriodRewardDistributions {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_QueryClaimPeriodRewardDistributionsByIDRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryClaimPeriodRewardDistributionsByIDRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reward_id"),
    2: .standard(proto: "claim_period_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.rewardID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.claimPeriodID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rewardID != 0 {
      try visitor.visitSingularUInt64Field(value: self.rewardID, fieldNumber: 1)
    }
    if self.claimPeriodID != 0 {
      try visitor.visitSingularUInt64Field(value: self.claimPeriodID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Provenance_Reward_V1_QueryClaimPeriodRewardDistributionsByIDRequest, rhs: Provenance_Reward_V1_QueryClaimPeriodRewardDistributionsByIDRequest) -> Bool {
    if lhs.rewardID != rhs.rewardID {return false}
    if lhs.claimPeriodID != rhs.claimPeriodID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_QueryClaimPeriodRewardDistributionsByIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryClaimPeriodRewardDistributionsByIDResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "claim_period_reward_distribution"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._claimPeriodRewardDistribution) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._claimPeriodRewardDistribution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Provenance_Reward_V1_QueryClaimPeriodRewardDistributionsByIDResponse, rhs: Provenance_Reward_V1_QueryClaimPeriodRewardDistributionsByIDResponse) -> Bool {
    if lhs._claimPeriodRewardDistribution != rhs._claimPeriodRewardDistribution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_QueryRewardDistributionsByAddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryRewardDistributionsByAddressRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "claim_status"),
    99: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.claimStatus) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.claimStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.claimStatus, fieldNumber: 2)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Provenance_Reward_V1_QueryRewardDistributionsByAddressRequest, rhs: Provenance_Reward_V1_QueryRewardDistributionsByAddressRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.claimStatus != rhs.claimStatus {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_QueryRewardDistributionsByAddressResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryRewardDistributionsByAddressResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "reward_account_state"),
    99: .same(proto: "pagination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rewardAccountState) }()
      case 99: try { try decoder.decodeSingularMessageField(value: &self._pagination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.rewardAccountState.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rewardAccountState, fieldNumber: 2)
    }
    if let v = self._pagination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Provenance_Reward_V1_QueryRewardDistributionsByAddressResponse, rhs: Provenance_Reward_V1_QueryRewardDistributionsByAddressResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.rewardAccountState != rhs.rewardAccountState {return false}
    if lhs._pagination != rhs._pagination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provenance_Reward_V1_RewardAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RewardAccountResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reward_program_id"),
    2: .standard(proto: "total_reward_claim"),
    3: .standard(proto: "claim_status"),
    4: .standard(proto: "claim_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.rewardProgramID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._totalRewardClaim) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.claimStatus) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.claimID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rewardProgramID != 0 {
      try visitor.visitSingularUInt64Field(value: self.rewardProgramID, fieldNumber: 1)
    }
    if let v = self._totalRewardClaim {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.claimStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.claimStatus, fieldNumber: 3)
    }
    if self.claimID != 0 {
      try visitor.visitSingularUInt64Field(value: self.claimID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Provenance_Reward_V1_RewardAccountResponse, rhs: Provenance_Reward_V1_RewardAccountResponse) -> Bool {
    if lhs.rewardProgramID != rhs.rewardProgramID {return false}
    if lhs._totalRewardClaim != rhs._totalRewardClaim {return false}
    if lhs.claimStatus != rhs.claimStatus {return false}
    if lhs.claimID != rhs.claimID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
