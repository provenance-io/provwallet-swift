// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tendermint/consensus/types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// NewRoundStep is sent for every step taken in the ConsensusState.
/// For every height/round/step transition
public struct Tendermint_Consensus_NewRoundStep {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: Int64 = 0

  public var round: Int32 = 0

  public var step: UInt32 = 0

  public var secondsSinceStartTime: Int64 = 0

  public var lastCommitRound: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// NewValidBlock is sent when a validator observes a valid block B in some round r,
/// i.e., there is a Proposal for block B and 2/3+ prevotes for the block B in the round r.
/// In case the block is also committed, then IsCommit flag is set to true.
public struct Tendermint_Consensus_NewValidBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: Int64 = 0

  public var round: Int32 = 0

  public var blockPartSetHeader: Tendermint_Types_PartSetHeader {
    get {return _blockPartSetHeader ?? Tendermint_Types_PartSetHeader()}
    set {_blockPartSetHeader = newValue}
  }
  /// Returns true if `blockPartSetHeader` has been explicitly set.
  public var hasBlockPartSetHeader: Bool {return self._blockPartSetHeader != nil}
  /// Clears the value of `blockPartSetHeader`. Subsequent reads from it will return its default value.
  public mutating func clearBlockPartSetHeader() {self._blockPartSetHeader = nil}

  public var blockParts: Tendermint_Libs_Bits_BitArray {
    get {return _blockParts ?? Tendermint_Libs_Bits_BitArray()}
    set {_blockParts = newValue}
  }
  /// Returns true if `blockParts` has been explicitly set.
  public var hasBlockParts: Bool {return self._blockParts != nil}
  /// Clears the value of `blockParts`. Subsequent reads from it will return its default value.
  public mutating func clearBlockParts() {self._blockParts = nil}

  public var isCommit: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _blockPartSetHeader: Tendermint_Types_PartSetHeader? = nil
  fileprivate var _blockParts: Tendermint_Libs_Bits_BitArray? = nil
}

/// Proposal is sent when a new block is proposed.
public struct Tendermint_Consensus_Proposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var proposal: Tendermint_Types_Proposal {
    get {return _proposal ?? Tendermint_Types_Proposal()}
    set {_proposal = newValue}
  }
  /// Returns true if `proposal` has been explicitly set.
  public var hasProposal: Bool {return self._proposal != nil}
  /// Clears the value of `proposal`. Subsequent reads from it will return its default value.
  public mutating func clearProposal() {self._proposal = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _proposal: Tendermint_Types_Proposal? = nil
}

/// ProposalPOL is sent when a previous proposal is re-proposed.
public struct Tendermint_Consensus_ProposalPOL {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: Int64 = 0

  public var proposalPolRound: Int32 = 0

  public var proposalPol: Tendermint_Libs_Bits_BitArray {
    get {return _proposalPol ?? Tendermint_Libs_Bits_BitArray()}
    set {_proposalPol = newValue}
  }
  /// Returns true if `proposalPol` has been explicitly set.
  public var hasProposalPol: Bool {return self._proposalPol != nil}
  /// Clears the value of `proposalPol`. Subsequent reads from it will return its default value.
  public mutating func clearProposalPol() {self._proposalPol = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _proposalPol: Tendermint_Libs_Bits_BitArray? = nil
}

/// BlockPart is sent when gossipping a piece of the proposed block.
public struct Tendermint_Consensus_BlockPart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: Int64 = 0

  public var round: Int32 = 0

  public var part: Tendermint_Types_Part {
    get {return _part ?? Tendermint_Types_Part()}
    set {_part = newValue}
  }
  /// Returns true if `part` has been explicitly set.
  public var hasPart: Bool {return self._part != nil}
  /// Clears the value of `part`. Subsequent reads from it will return its default value.
  public mutating func clearPart() {self._part = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _part: Tendermint_Types_Part? = nil
}

/// Vote is sent when voting for a proposal (or lack thereof).
public struct Tendermint_Consensus_Vote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var vote: Tendermint_Types_Vote {
    get {return _vote ?? Tendermint_Types_Vote()}
    set {_vote = newValue}
  }
  /// Returns true if `vote` has been explicitly set.
  public var hasVote: Bool {return self._vote != nil}
  /// Clears the value of `vote`. Subsequent reads from it will return its default value.
  public mutating func clearVote() {self._vote = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _vote: Tendermint_Types_Vote? = nil
}

/// HasVote is sent to indicate that a particular vote has been received.
public struct Tendermint_Consensus_HasVote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: Int64 = 0

  public var round: Int32 = 0

  public var type: Tendermint_Types_SignedMsgType = .unknown

  public var index: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// VoteSetMaj23 is sent to indicate that a given BlockID has seen +2/3 votes.
public struct Tendermint_Consensus_VoteSetMaj23 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: Int64 = 0

  public var round: Int32 = 0

  public var type: Tendermint_Types_SignedMsgType = .unknown

  public var blockID: Tendermint_Types_BlockID {
    get {return _blockID ?? Tendermint_Types_BlockID()}
    set {_blockID = newValue}
  }
  /// Returns true if `blockID` has been explicitly set.
  public var hasBlockID: Bool {return self._blockID != nil}
  /// Clears the value of `blockID`. Subsequent reads from it will return its default value.
  public mutating func clearBlockID() {self._blockID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _blockID: Tendermint_Types_BlockID? = nil
}

/// VoteSetBits is sent to communicate the bit-array of votes seen for the BlockID.
public struct Tendermint_Consensus_VoteSetBits {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: Int64 = 0

  public var round: Int32 = 0

  public var type: Tendermint_Types_SignedMsgType = .unknown

  public var blockID: Tendermint_Types_BlockID {
    get {return _blockID ?? Tendermint_Types_BlockID()}
    set {_blockID = newValue}
  }
  /// Returns true if `blockID` has been explicitly set.
  public var hasBlockID: Bool {return self._blockID != nil}
  /// Clears the value of `blockID`. Subsequent reads from it will return its default value.
  public mutating func clearBlockID() {self._blockID = nil}

  public var votes: Tendermint_Libs_Bits_BitArray {
    get {return _votes ?? Tendermint_Libs_Bits_BitArray()}
    set {_votes = newValue}
  }
  /// Returns true if `votes` has been explicitly set.
  public var hasVotes: Bool {return self._votes != nil}
  /// Clears the value of `votes`. Subsequent reads from it will return its default value.
  public mutating func clearVotes() {self._votes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _blockID: Tendermint_Types_BlockID? = nil
  fileprivate var _votes: Tendermint_Libs_Bits_BitArray? = nil
}

public struct Tendermint_Consensus_Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sum: Tendermint_Consensus_Message.OneOf_Sum? = nil

  public var newRoundStep: Tendermint_Consensus_NewRoundStep {
    get {
      if case .newRoundStep(let v)? = sum {return v}
      return Tendermint_Consensus_NewRoundStep()
    }
    set {sum = .newRoundStep(newValue)}
  }

  public var newValidBlock: Tendermint_Consensus_NewValidBlock {
    get {
      if case .newValidBlock(let v)? = sum {return v}
      return Tendermint_Consensus_NewValidBlock()
    }
    set {sum = .newValidBlock(newValue)}
  }

  public var proposal: Tendermint_Consensus_Proposal {
    get {
      if case .proposal(let v)? = sum {return v}
      return Tendermint_Consensus_Proposal()
    }
    set {sum = .proposal(newValue)}
  }

  public var proposalPol: Tendermint_Consensus_ProposalPOL {
    get {
      if case .proposalPol(let v)? = sum {return v}
      return Tendermint_Consensus_ProposalPOL()
    }
    set {sum = .proposalPol(newValue)}
  }

  public var blockPart: Tendermint_Consensus_BlockPart {
    get {
      if case .blockPart(let v)? = sum {return v}
      return Tendermint_Consensus_BlockPart()
    }
    set {sum = .blockPart(newValue)}
  }

  public var vote: Tendermint_Consensus_Vote {
    get {
      if case .vote(let v)? = sum {return v}
      return Tendermint_Consensus_Vote()
    }
    set {sum = .vote(newValue)}
  }

  public var hasVote_p: Tendermint_Consensus_HasVote {
    get {
      if case .hasVote_p(let v)? = sum {return v}
      return Tendermint_Consensus_HasVote()
    }
    set {sum = .hasVote_p(newValue)}
  }

  public var voteSetMaj23: Tendermint_Consensus_VoteSetMaj23 {
    get {
      if case .voteSetMaj23(let v)? = sum {return v}
      return Tendermint_Consensus_VoteSetMaj23()
    }
    set {sum = .voteSetMaj23(newValue)}
  }

  public var voteSetBits: Tendermint_Consensus_VoteSetBits {
    get {
      if case .voteSetBits(let v)? = sum {return v}
      return Tendermint_Consensus_VoteSetBits()
    }
    set {sum = .voteSetBits(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Sum: Equatable {
    case newRoundStep(Tendermint_Consensus_NewRoundStep)
    case newValidBlock(Tendermint_Consensus_NewValidBlock)
    case proposal(Tendermint_Consensus_Proposal)
    case proposalPol(Tendermint_Consensus_ProposalPOL)
    case blockPart(Tendermint_Consensus_BlockPart)
    case vote(Tendermint_Consensus_Vote)
    case hasVote_p(Tendermint_Consensus_HasVote)
    case voteSetMaj23(Tendermint_Consensus_VoteSetMaj23)
    case voteSetBits(Tendermint_Consensus_VoteSetBits)

  #if !swift(>=4.1)
    public static func ==(lhs: Tendermint_Consensus_Message.OneOf_Sum, rhs: Tendermint_Consensus_Message.OneOf_Sum) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.newRoundStep, .newRoundStep): return {
        guard case .newRoundStep(let l) = lhs, case .newRoundStep(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.newValidBlock, .newValidBlock): return {
        guard case .newValidBlock(let l) = lhs, case .newValidBlock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.proposal, .proposal): return {
        guard case .proposal(let l) = lhs, case .proposal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.proposalPol, .proposalPol): return {
        guard case .proposalPol(let l) = lhs, case .proposalPol(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.blockPart, .blockPart): return {
        guard case .blockPart(let l) = lhs, case .blockPart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vote, .vote): return {
        guard case .vote(let l) = lhs, case .vote(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hasVote_p, .hasVote_p): return {
        guard case .hasVote_p(let l) = lhs, case .hasVote_p(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.voteSetMaj23, .voteSetMaj23): return {
        guard case .voteSetMaj23(let l) = lhs, case .voteSetMaj23(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.voteSetBits, .voteSetBits): return {
        guard case .voteSetBits(let l) = lhs, case .voteSetBits(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tendermint.consensus"

extension Tendermint_Consensus_NewRoundStep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NewRoundStep"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "round"),
    3: .same(proto: "step"),
    4: .standard(proto: "seconds_since_start_time"),
    5: .standard(proto: "last_commit_round"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.round) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.step) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.secondsSinceStartTime) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.lastCommitRound) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 1)
    }
    if self.round != 0 {
      try visitor.visitSingularInt32Field(value: self.round, fieldNumber: 2)
    }
    if self.step != 0 {
      try visitor.visitSingularUInt32Field(value: self.step, fieldNumber: 3)
    }
    if self.secondsSinceStartTime != 0 {
      try visitor.visitSingularInt64Field(value: self.secondsSinceStartTime, fieldNumber: 4)
    }
    if self.lastCommitRound != 0 {
      try visitor.visitSingularInt32Field(value: self.lastCommitRound, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tendermint_Consensus_NewRoundStep, rhs: Tendermint_Consensus_NewRoundStep) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.round != rhs.round {return false}
    if lhs.step != rhs.step {return false}
    if lhs.secondsSinceStartTime != rhs.secondsSinceStartTime {return false}
    if lhs.lastCommitRound != rhs.lastCommitRound {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Consensus_NewValidBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NewValidBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "round"),
    3: .standard(proto: "block_part_set_header"),
    4: .standard(proto: "block_parts"),
    5: .standard(proto: "is_commit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.round) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._blockPartSetHeader) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._blockParts) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isCommit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 1)
    }
    if self.round != 0 {
      try visitor.visitSingularInt32Field(value: self.round, fieldNumber: 2)
    }
    if let v = self._blockPartSetHeader {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._blockParts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.isCommit != false {
      try visitor.visitSingularBoolField(value: self.isCommit, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tendermint_Consensus_NewValidBlock, rhs: Tendermint_Consensus_NewValidBlock) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.round != rhs.round {return false}
    if lhs._blockPartSetHeader != rhs._blockPartSetHeader {return false}
    if lhs._blockParts != rhs._blockParts {return false}
    if lhs.isCommit != rhs.isCommit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Consensus_Proposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Proposal"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proposal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._proposal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._proposal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tendermint_Consensus_Proposal, rhs: Tendermint_Consensus_Proposal) -> Bool {
    if lhs._proposal != rhs._proposal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Consensus_ProposalPOL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProposalPOL"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .standard(proto: "proposal_pol_round"),
    3: .standard(proto: "proposal_pol"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.proposalPolRound) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._proposalPol) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 1)
    }
    if self.proposalPolRound != 0 {
      try visitor.visitSingularInt32Field(value: self.proposalPolRound, fieldNumber: 2)
    }
    if let v = self._proposalPol {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tendermint_Consensus_ProposalPOL, rhs: Tendermint_Consensus_ProposalPOL) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.proposalPolRound != rhs.proposalPolRound {return false}
    if lhs._proposalPol != rhs._proposalPol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Consensus_BlockPart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockPart"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "round"),
    3: .same(proto: "part"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.round) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._part) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 1)
    }
    if self.round != 0 {
      try visitor.visitSingularInt32Field(value: self.round, fieldNumber: 2)
    }
    if let v = self._part {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tendermint_Consensus_BlockPart, rhs: Tendermint_Consensus_BlockPart) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.round != rhs.round {return false}
    if lhs._part != rhs._part {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Consensus_Vote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vote"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._vote) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._vote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tendermint_Consensus_Vote, rhs: Tendermint_Consensus_Vote) -> Bool {
    if lhs._vote != rhs._vote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Consensus_HasVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HasVote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "round"),
    3: .same(proto: "type"),
    4: .same(proto: "index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.round) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 1)
    }
    if self.round != 0 {
      try visitor.visitSingularInt32Field(value: self.round, fieldNumber: 2)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tendermint_Consensus_HasVote, rhs: Tendermint_Consensus_HasVote) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.round != rhs.round {return false}
    if lhs.type != rhs.type {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Consensus_VoteSetMaj23: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VoteSetMaj23"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "round"),
    3: .same(proto: "type"),
    4: .standard(proto: "block_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.round) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._blockID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 1)
    }
    if self.round != 0 {
      try visitor.visitSingularInt32Field(value: self.round, fieldNumber: 2)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if let v = self._blockID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tendermint_Consensus_VoteSetMaj23, rhs: Tendermint_Consensus_VoteSetMaj23) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.round != rhs.round {return false}
    if lhs.type != rhs.type {return false}
    if lhs._blockID != rhs._blockID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Consensus_VoteSetBits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VoteSetBits"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "round"),
    3: .same(proto: "type"),
    4: .standard(proto: "block_id"),
    5: .same(proto: "votes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.round) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._blockID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._votes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 1)
    }
    if self.round != 0 {
      try visitor.visitSingularInt32Field(value: self.round, fieldNumber: 2)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if let v = self._blockID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._votes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tendermint_Consensus_VoteSetBits, rhs: Tendermint_Consensus_VoteSetBits) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.round != rhs.round {return false}
    if lhs.type != rhs.type {return false}
    if lhs._blockID != rhs._blockID {return false}
    if lhs._votes != rhs._votes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Consensus_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Message"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_round_step"),
    2: .standard(proto: "new_valid_block"),
    3: .same(proto: "proposal"),
    4: .standard(proto: "proposal_pol"),
    5: .standard(proto: "block_part"),
    6: .same(proto: "vote"),
    7: .standard(proto: "has_vote"),
    8: .standard(proto: "vote_set_maj23"),
    9: .standard(proto: "vote_set_bits"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Tendermint_Consensus_NewRoundStep?
        if let current = self.sum {
          try decoder.handleConflictingOneOf()
          if case .newRoundStep(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sum = .newRoundStep(v)}
      }()
      case 2: try {
        var v: Tendermint_Consensus_NewValidBlock?
        if let current = self.sum {
          try decoder.handleConflictingOneOf()
          if case .newValidBlock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sum = .newValidBlock(v)}
      }()
      case 3: try {
        var v: Tendermint_Consensus_Proposal?
        if let current = self.sum {
          try decoder.handleConflictingOneOf()
          if case .proposal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sum = .proposal(v)}
      }()
      case 4: try {
        var v: Tendermint_Consensus_ProposalPOL?
        if let current = self.sum {
          try decoder.handleConflictingOneOf()
          if case .proposalPol(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sum = .proposalPol(v)}
      }()
      case 5: try {
        var v: Tendermint_Consensus_BlockPart?
        if let current = self.sum {
          try decoder.handleConflictingOneOf()
          if case .blockPart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sum = .blockPart(v)}
      }()
      case 6: try {
        var v: Tendermint_Consensus_Vote?
        if let current = self.sum {
          try decoder.handleConflictingOneOf()
          if case .vote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sum = .vote(v)}
      }()
      case 7: try {
        var v: Tendermint_Consensus_HasVote?
        if let current = self.sum {
          try decoder.handleConflictingOneOf()
          if case .hasVote_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sum = .hasVote_p(v)}
      }()
      case 8: try {
        var v: Tendermint_Consensus_VoteSetMaj23?
        if let current = self.sum {
          try decoder.handleConflictingOneOf()
          if case .voteSetMaj23(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sum = .voteSetMaj23(v)}
      }()
      case 9: try {
        var v: Tendermint_Consensus_VoteSetBits?
        if let current = self.sum {
          try decoder.handleConflictingOneOf()
          if case .voteSetBits(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sum = .voteSetBits(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.sum {
    case .newRoundStep?: try {
      guard case .newRoundStep(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .newValidBlock?: try {
      guard case .newValidBlock(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .proposal?: try {
      guard case .proposal(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .proposalPol?: try {
      guard case .proposalPol(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .blockPart?: try {
      guard case .blockPart(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .vote?: try {
      guard case .vote(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .hasVote_p?: try {
      guard case .hasVote_p(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .voteSetMaj23?: try {
      guard case .voteSetMaj23(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .voteSetBits?: try {
      guard case .voteSetBits(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tendermint_Consensus_Message, rhs: Tendermint_Consensus_Message) -> Bool {
    if lhs.sum != rhs.sum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
